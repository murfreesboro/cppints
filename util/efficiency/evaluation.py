"""
this file is used to evaluate the efficiency of the 
cpp code generated by the cppints

We do not analyze the all S file. It's trivial case

for future update:
if you have more codes adding in, please check the 
function of has_K4 and has_hrr
both of the two functions may need to have a change
"""
__author__  = "Fenglai Liu"
__date__    = "Jan, 2014"
import sys
import os
import re

#
#  data section
#  we do not count in if else operation as well as loop operation cost
#  we also can not count in the special function cost
#  namely, sqrt, erf, in-complete gamma, and exp
#
file_name    = "  "     # the cpp file name for parsing
has_hrr_part = True     # whether we have HRR part in the code
has_k4_part  = False    # whether we have K4 loop
hrr_var_num  = 0        # the counting of local HRR memory use (either in var or vector)
vrr_var_num  = 0        # the counting of local VRR memory use (either in var or vector)
hrr_vec_nvar = 0        # the counting of local HRR memory use (only in vector)
vrr_vec_nvar = 0        # the counting of local VRR memory use (only in vector)
n_ignore_vrr = 0        # number of ignore integrals in VRR part
n_ignore_hrr = 0        # number of ignore integrals in HRR part
n_add_k2     = 0        # number of adding/substracting operations for K2 loop
n_mul_k2     = 0        # number of multiplication/dividing operations for K2 loop
n_vec_k2     = 0        # number of operations to retrieve data from vector for K2 loop
n_ass_k2     = 0        # number of operations to assign a double value for K2 loop
n_add_k4     = 0        # number of adding/substracting operations for K4 loop
n_mul_k4     = 0        # number of multiplication/dividing operations for K4 loop
n_vec_k4     = 0        # number of operations to retrieve data from vector for K4 loop
n_ass_k4     = 0        # number of operations to assign a double value for K4 loop
n_add_hrr    = 0        # number of adding/substracting operations for HRR
n_mul_hrr    = 0        # number of multiplication/dividing operations for HRR
n_vec_hrr    = 0        # number of operations to retrieve data from vector for HRR
n_ass_hrr    = 0        # number of operations to assign a double value for HRR

def goto_beginning(f):
	"""
	for the given file handler, we go to 
	the begining of function
	"""
	# rewind the file to the beginning
	f.seek(0)

	# now go to the beginning of function
	while True:
		line = f.readline()
		if re.search(r"^{", line) is not None: 
			break

def is_comment(line):
	"""
	whether this line is comment
	"""
	newline = line.strip()
	if re.search(r"^//", newline) is not None: 
		return True
	if re.search(r"^\*", newline) is not None: 
		return True
	return False

def is_shell_symbol(s):
	"""
	whether the given s is shell symbol
	"""
	if s == "S" or s == "s":
		return True
	elif s == "P" or s == "p":
		return True
	elif s == "SP" or s == "sp":
		return True
	elif s == "D" or s == "d":
		return True
	elif s == "F" or s == "f":
		return True
	elif s == "G" or s == "g":
		return True
	elif s == "H" or s == "h":
		return True
	elif s == "I" or s == "i":
		return True
	elif s == "K" or s == "k":
		return True
	elif s == "L" or s == "l":
		return True
	elif s == "M" or s == "m":
		return True
	elif s == "N" or s == "n":
		return True
	elif s == "O" or s == "o":
		return True
	elif s == "Q" or s == "q":
		return True
	elif s == "R" or s == "r":
		return True
	elif s == "T" or s == "t":
		return True
	elif s == "U" or s == "u":
		return True
	elif s == "V" or s == "v":
		return True
	elif s == "W" or s == "w":
		return True
	elif s == "X" or s == "x":
		return True
	elif s == "Y" or s == "y":
		return True
	elif s == "Z" or s == "z":
		return True
	else:

		# if L>20, then L symbol
		# is defined as L+number
		# we will see whether this 
		# is the case
		if s[0] == "L" and len(s) > 1:
			n = s[1:]
			if n.isdigit():
				x = int(n)
				if x >= 21:
					return True
			else:
				return False

		# now this is not the 
		# angular momentum
		return False

def has_K4():
	"""
	juding whether we have K4 loop
	this is done by parsing the file name
	only the four body operator has it
	"""
	global file_name
	name   = os.path.splitext(file_name)[0]
	fields = name.split("_") 

	# we will list all of situations
	for i in fields:
		if i == "ERI" or i == "eri":
			return True
		if i == "twobodyoverlap" or i == "TWOBODYOVERLAP":
			return False
		if i == "mom" or i == "MOM":
			return False
		if i == "threebodyoverlap" or i == "THREEBODYOVERLAP":
			return True
		if i == "threebodyki" or i == "THREEBODYKI":
			return True
		if i == "esp" or i == "ESP":
			return False
		if i == "nai" or i == "nai":
			return False
		if i == "kinetic" or i == "kinetic":
			return False

	# 
	# if we arrive here, report an error
	# 
	print name
	print "in has_k4, the operator name is unknown\n"
	sys.exit()
	
def has_hrr():
	"""
	juding whether we have HRR part 
	this is done by parsing the file name
	"""
	global file_name

	# pre-setting
	bra_has_hrr = True
	ket_has_hrr = True

	# take a look of the operator
	can_oper_do_hrr = True

	# get the angular part
	name   = os.path.splitext(file_name)[0]
	fields = name.split("_") 
	ang    = [ ] 
	for i in fields:
		if is_shell_symbol(i):
			ang.append(i)
		if i == "KINETIC" or i == "kinetic":
			can_oper_do_hrr = False
		if i == "THREEBODYKI" or i == "threebodyki":
			can_oper_do_hrr = False
	
	# for the operator can not do hrr
	# we return false
	if not can_oper_do_hrr:
		return False

	# now let's analyze the angular part
	length = len(ang)
	
	# one body operator surely do not have HRR
	if length == 1:
		return False
	
	# to see the bra side
	if length >= 2:
		sym = ang[0]
		if sym == "S" or sym == "s":
			bra_has_hrr = False
		sym = ang[1]
		if sym == "S" or sym == "s":
			bra_has_hrr = False

	# to see the ket side
	if length == 4:
		sym = ang[2]
		if sym == "S" or sym == "s":
			ket_has_hrr = False
		sym = ang[3]
		if sym == "S" or sym == "s":
			ket_has_hrr = False
	
	# finally, it's only 4 body integral
	# can do the ket HRR
	if length < 4:
		ket_has_hrr = False

	# if bra/ket is true, then we have HRR
	return bra_has_hrr or ket_has_hrr

def with_hrr():
	"""
	provide a function to return the hrr status
	"""
	global has_hrr_part
	return has_hrr_part

def initilize(fname):
	"""
	initilize the variables for the running
	"""
	global file_name   
	global has_k4_part
	global has_hrr_part
	global hrr_var_num 
	global vrr_var_num 
	global hrr_vec_nvar 
	global vrr_vec_nvar
	global n_add_k2    
	global n_mul_k2    
	global n_vec_k2    
	global n_ass_k2    
	global n_add_k4    
	global n_mul_k4    
	global n_vec_k4    
	global n_ass_k4    
	global n_add_hrr    
	global n_mul_hrr    
	global n_vec_hrr    
	global n_ass_hrr    
	global n_ignore_vrr    
	global n_ignore_hrr    

	file_name    = os.path.basename(fname)  
	has_hrr_part = has_hrr()
	has_k4_part  = has_K4()
	hrr_var_num  = 0
	vrr_var_num  = 0
	hrr_vec_nvar = 0
	vrr_vec_nvar = 0
	n_add_k2     = 0
	n_mul_k2     = 0      
	n_vec_k2     = 0     
	n_ass_k2     = 0    
	n_add_k4     = 0   
	n_mul_k4     = 0  
	n_vec_k4     = 0 
	n_ass_k4     = 0
	n_add_hrr    = 0   
	n_mul_hrr    = 0  
	n_vec_hrr    = 0 
	n_ass_hrr    = 0
	n_ignore_hrr = 0
	n_ignore_vrr = 0

def hrr_analyze(fname):
	"""
	analyze the HRR part of codes
	"""
	global hrr_var_num 
	global hrr_vec_nvar 
	global n_add_hrr    
	global n_mul_hrr    
	global n_vec_hrr    
	global n_ass_hrr    

	# firstly, go to the beginning to get HRR information
	name = open(fname, "r")
	goto_beginning(name)

	# let's go to the VRR's real code
	# this is corresponding to the section of VRR
	while True:
		line = name.readline()
		if re.search(r"{", line) is not None: 
			break
		if is_comment(line) or line.isspace():
			continue

		# if we reach the end of line, report an error
		if not line: 
			print "in hrr_analyze, we did not get the vrr beginning??\n"
			sys.exit()

		# let's count how many variables defined here
		# the variables are defined in two ways:
		# one is with vector, else must be double var
		if re.search(r"DoubleVec", line) is not None: 
			begin = line.index("(")
			end   = line.index(",")
			num   = line[begin+1:end]
			n     = int(num)
			n_ass_hrr = n_ass_hrr + n
			hrr_var_num = hrr_var_num + n
			hrr_vec_nvar = hrr_vec_nvar + n
		elif re.search(r"getNewMemPos", line) is not None: 
			begin = line.index("(")
			end   = line.index(")")
			num   = line[begin+1:end]
			n     = int(num)
			n_ass_hrr = n_ass_hrr + n
			hrr_var_num = hrr_var_num + n
			hrr_vec_nvar = hrr_vec_nvar + n
		else:
			n_ass_hrr = n_ass_hrr + 1
			hrr_var_num = hrr_var_num + 1

	# now let's go to the real HRR part
	while True:
		line = name.readline()
		if re.search(r"HRR", line) is not None and is_comment(line): 
			break

		# if we reach the end of line, report an error
		if not line: 
			print "in hrr_analyze, we did not get to hrr beginning??\n"
			sys.exit()


	# now we begin the HRR part
	while True:
		line = name.readline()
		newline = line.strip()

		# omit the non-code lines
		if is_comment(line) or line.isspace():
			continue

		# jump out the end of file
		if not line: break 

		# whether we declare a vector?
		if re.search(r"DoubleVec", line) is not None: 
			begin = newline.index("(")
			end   = newline.index(",")
			num   = newline[begin+1:end]
			n     = int(num)
			n_ass_hrr = n_ass_hrr + n
			hrr_var_num = hrr_var_num + n
			hrr_vec_nvar = hrr_vec_nvar + n
		elif re.search(r"getNewMemPos", line) is not None: 
			begin = newline.index("(")
			end   = newline.index(")")
			num   = newline[begin+1:end]
			n     = int(num)
			n_ass_hrr = n_ass_hrr + n
			hrr_var_num = hrr_var_num + n
			hrr_vec_nvar = hrr_vec_nvar + n

		# whether we see an line for calculation?
		elif re.search(r"=", newline) is not None: 
			n_ass_hrr = n_ass_hrr + 1

			# whether this is a new double var?
			if re.search(r"^Double", newline) is not None: 
				hrr_var_num = hrr_var_num + 1

			# counting the number of adding/substracting
			n = newline.count('+')
			n_add_hrr = n_add_hrr + n   
			n = newline.count('-')
			n_add_hrr = n_add_hrr + n   

			# counting the number of multiplication/dividing
			n = newline.count('*')
			n_mul_hrr = n_mul_hrr + n   
			n = newline.count('/')
			n_mul_hrr = n_mul_hrr + n   

			# counting the number of retrieving data from vector
			n = newline.count('[')
			n_vec_hrr = n_vec_hrr + n   

	# finally, close the file
	name.close()

def vrr_analyze(fname):
	"""
	analyze the VRR part of codes
	"""
	global vrr_var_num 
	global vrr_vec_nvar 
	global has_k4_part
	global n_add_k2    
	global n_mul_k2    
	global n_vec_k2    
	global n_ass_k2    
	global n_add_k4    
	global n_mul_k4    
	global n_vec_k4    
	global n_ass_k4    

	# firstly, go to the beginning to get HRR information
	name = open(fname, "r")
	goto_beginning(name)

	# sections to indicate the K2 area and K4 area
	K4_start = False

	# let's go to the VRR's real code
	# this is corresponding to the section of VRR
	while True:
		line = name.readline()
		if is_comment(line) or line.isspace():
			continue
		if re.search(r"{", line) is not None: 
			break

		# if we reach the end of line, report an error
		if not line: 
			print fname
			print "in vrr_analyze, we did not get to vrr beginning??\n"
			sys.exit()

	# now let's go to the VRR part
	# we note that we only count in the codes for double type
	inSinglePrecisionZone = False
	while True:
		line = name.readline()
		newline = line.strip()

		#
		# VRR is more complicated then HRR section
		# here we have a lot of situations
		# therefore situation judgement will go first
		#

		# 
                # now we step out of VRR, stop here
		# 
		if re.search(r"HRR", line) is not None and is_comment(line): 
			break

		# omit the non-code lines
		if is_comment(line) or line.isspace():
			continue

		# whether we begin the single precision zone?
		if re.search(r"WITH_SINGLE_PRECISION", newline) is not None \
				and re.search(r"ifdef", newline) is not None: 
			inSinglePrecisionZone = True

		# whether the single precision zone ends?
		if inSinglePrecisionZone:
			if re.search(r"#endif", newline) is not None \
					or re.search(r"#else", newline) is not None: 
				inSinglePrecisionZone = False

		# if we are in the single precision zone, we omit
		# all of codes
		if inSinglePrecisionZone:
			continue

		# whether the K4 section begins?
		# we note that here the judgement is safe
		# the code in K2 loop is simple do not have if else etc.
		if has_k4_part:
			if re.search(r"{", newline) is not None and \
					re.search(r"for", newline) is not None and not K4_start: 
				K4_start = True


		# if we reach the end of line, that means only VRR in the cpp file
                # just step out
		if not line: 
                        break

		#
		# now we begin the evalulation part
		#

		# whether we declare a vector?
		if re.search(r"DoubleVec", line) is not None: 
			begin = newline.index("(")
			end   = newline.index(",")
			num   = newline[begin+1:end]
			n     = int(num)
			if K4_start:
				n_ass_k4 = n_ass_k4 + n
			else:
				n_ass_k2 = n_ass_k2 + n
			vrr_var_num = vrr_var_num + n
			vrr_vec_nvar = vrr_vec_nvar + n
		elif re.search(r"getNewMemPos", line) is not None: 
			begin = newline.index("(")
			end   = newline.index(")")
			num   = newline[begin+1:end]
			n     = int(num)
			if K4_start:
				n_ass_k4 = n_ass_k4 + n
			else:
				n_ass_k2 = n_ass_k2 + n
			vrr_var_num = vrr_var_num + n
			vrr_vec_nvar = vrr_vec_nvar + n

		# whether we see an line for calculation?
		elif re.search(r"=", newline) is not None: 
                        #print newline
			if K4_start:
				n_ass_k4 = n_ass_k4 + 1
			else:
				n_ass_k2 = n_ass_k2 + 1

			# whether this is a double var?
			if re.search(r"^Double", newline) is not None: 
				vrr_var_num = vrr_var_num + 1

			# counting the number of adding/substracting
			# we also consider the > and < here
			n1 = newline.count('+')
			n2 = newline.count('-')
			n  = n1 + n2 
			if K4_start:
				n_add_k4 = n_add_k4 + n   
			else:
				n_add_k2 = n_add_k2 + n   
                        #print "+", n1
                        #print "-", n2
                        #print "total", n_add_k4+n_mul_k4

			# counting the number of multiplication/dividing
			n1 = newline.count('*')
			n2 = newline.count('/')
			n  = n1 + n2 
			if K4_start:
				n_mul_k4 = n_mul_k4 + n   
			else:
				n_mul_k2 = n_mul_k2 + n   
                        #print "*", n1
                        #print "/", n2
                        #print "total", n_add_k4+n_mul_k4

			# counting the number of retrieving data from vector
			n = newline.count('[')
			if K4_start:
				n_vec_k4 = n_vec_k4 + n   
			else:
				n_vec_k2 = n_vec_k2 + n   

	# finally, close the file
	name.close()

def infor_print():
	"""
	print out the results
	"""
	global file_name   
	global has_hrr_part
	global has_k4_part
	global hrr_var_num 
	global vrr_var_num 
	global hrr_vec_nvar 
	global vrr_vec_nvar 
	global n_add_k2    
	global n_mul_k2    
	global n_vec_k2    
	global n_ass_k2    
	global n_add_k4    
	global n_mul_k4    
	global n_vec_k4    
	global n_ass_k4    
	global n_add_hrr    
	global n_mul_hrr    
	global n_vec_hrr    
	global n_ass_hrr    

	print "*************************************************************************"
	print "for file ", file_name
	print "VRR section:"
	print "number of variables    : ", vrr_var_num
	print "number of vector vars  : ", vrr_vec_nvar
	print "number of + and - in K2: ", n_add_k2
	print "number of * and / in K2: ", n_mul_k2
	print "number of []      in K2: ", n_vec_k2
	print "number of =       in K2: ", n_ass_k2
	if has_k4_part:
		print "number of + and - in K4: ", n_add_k4
		print "number of * and / in K4: ", n_mul_k4
		print "number of []      in K4: ", n_vec_k4
		print "number of =       in K4: ", n_ass_k4
	if has_hrr_part:
		print "HRR section:"
		print "number of variables     : ", hrr_var_num
		print "number of vector vars   : ", hrr_vec_nvar
		print "number of + and - in HRR: ", n_add_hrr
		print "number of * and / in HRR: ", n_mul_hrr
		print "number of []      in HRR: ", n_vec_hrr
		print "number of =       in HRR: ", n_ass_hrr
	print "*************************************************************************\n\n"

def shell_quartets_infor(fname):
	"""
	print out the shell quartet chains we formed in the codes
	as well as it's ignore integral list
	"""
	global file_name   
	global has_hrr_part
	global n_ignore_hrr
	global n_ignore_vrr

	for section in range(0, 2):

		# section 0 is VRR
		# section 1 is HRR
		# VRR is always exist
		if section == 1 and not has_hrr_part:
			continue

		# now get the shell quartet names
		# as well as it's ignore integrals
		sqlist   = [ ]
		intlist  = [ ]
		name = open(fname, "r")

		# firstly, we get to HRR/VRR part 
		if section == 1:
			while True:
				line   = name.readline()
				if not line: 
                                        return
				if re.search(r"HRR", line) is not None: 
					break
		else:
			while True:
				line   = name.readline()
				if not line: 
                                        return
				if re.search(r"shell quartet name", line) is not None: 
					break

		# parse the data 
		while True:
			line   = name.readline()
			newline= line.strip()

			# when we step out?
			if re.search(r"}", line) is not None: 
				break

			# set the values
			sqname = None
			ignore = 0

			# shell quartet name
			if re.search(r"shell quartet name", newline) is not None: 
				tmp = newline.split(":")
				sqname = tmp[1]

			# this is related to the ignore list
			# we need to read another line
			if sqname is not None:
				line     = name.readline()
				newline  = line.strip()

				# integral number count
				if re.search(r"integrals are omitted", newline) is not None: 
					tmp = newline.split(" ")
					pos = tmp.index("totally")
					n = tmp[pos+1]
					ignore = int(n)

				# contraction step
				if re.search(r"contraction work", newline) is not None: 
					ignore = -1

				# take the result
				if sqlist.count(sqname) == 0:
					sqlist.append(sqname)
					intlist.append(ignore)

		# now close the file
		name.close()

		# count the total number of ignore integrals
		if section == 0:
			for i in intlist:
				if i>=0:
					n_ignore_vrr = n_ignore_vrr + i
		else:
			for i in intlist:
				if i>=0:
					n_ignore_hrr = n_ignore_hrr + i

		# let's print out the information
		print "*************************************************************************"
		print "for file ", file_name, "shell quartet map"
		print "From the bottom shell quartet integrals to the result ones "
		if section == 0:
			print "VRR section: ", "with total ignore integrals of: ", n_ignore_vrr
		else:
			print "HRR section: ", "with total ignore integrals of: ", n_ignore_hrr
		length = len(sqlist)
		for i in range(length):
			k = sqlist[i]
			v = intlist[i]
			if v == -1:
				print "shell quartet in contraction ", k
			else:
				print "number of integrals omitted: ", v, k
		print "*************************************************************************\n\n"





